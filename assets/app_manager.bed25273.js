import{o as e,c as n,b as i,e as a,r as t,l as r,u as o}from"./vendor.1180558b.js";var s="/assets/app-manager-01.5aaff6ed.png",g="/assets/app-manager-02.2aff8a98.png";const l={class:"markdown-body"},c=[i("h2",null,"1. Background",-1),i("p",null,"        The Entrance module of the old version of Linkis is responsible for too much responsibilities, the management ability of the Engine is weak, and it is not easy to follow-up expansion, the AppManager module is newly extracted to complete the following responsibilities:",-1),i("ol",null,[i("li",null,"Add the AM module to move the engine management function previously done by Entrance to the AM module."),i("li",null,"AM needs to support operating Engine, including: adding, multiplexing, recycling, preheating, switching and other functions."),i("li",null,"Need to connect to the Manager module to provide Engine management functions: including Engine status maintenance, engine list maintenance, engine information, etc."),i("li",null,"AM needs to manage EM services, complete EM registration and forward the resource registration to RM."),i("li",null,"AM needs to be connected to the Label module, including the addition and deletion of EM/Engine, the label manager needs to be notified to update the label."),i("li",null,"AM also needs to dock the label module for label analysis, and need to obtain a list of serverInstances with a series of scores through a series of labels (How to distinguish between EM and Engine? the labels are completely different)."),i("li",null,"Need to provide external basic interface: including the addition, deletion and modification of engine and engine manager, metric query, etc.")],-1),i("h2",null,"Architecture diagram",-1),i("p",null,[i("img",{src:s,alt:"AppManager03"}),a("         As shown in the figure above: AM belongs to the AppManager module in LinkisMaster and provides services.         New engine application flow chart: "),i("img",{src:g,alt:"AppManager02"}),a("         From the above engine life cycle flow chart, it can be seen that Entrance is no longer doing the management of the Engine, and the startup and management of the engine are controlled by AM.")],-1),i("h2",null,"Architecture description",-1),i("p",null,"        AppManager mainly includes engine service and EM service: Engine service includes all operations related to EngineConn, such as engine creation, engine reuse, engine switching, engine recycling, engine stopping, engine destruction, etc. EM service is responsible for information management of all EngineConnManager, and can perform service management on ECM online, including tag modification, suspension of ECM service, obtaining ECM instance information, obtaining ECM running engine information, killing ECM operation, and also according to EM Node information Query all EngineNodes, and also support searching by user, saving EM Node load information, node health information, resource usage information, etc. The new EngineConnManager and EngineConn both support tag management, and the types of engines have also added offline, streaming, and interactive support.",-1),i("p",null,"        Engine creation: specifically responsible for the new engine function of the LinkisManager service. The engine startup module is fully responsible for the creation of a new engine, including obtaining ECM tag collections, resource requests, obtaining engine startup commands, notifying ECM to create new engines, updating engine lists, etc. CreateEngienRequest->RPC/Rest -> MasterEventHandler ->CreateEngineService -> ->LabelContext/EnginePlugin/RMResourcevice->(RcycleEngineService)EngineNodeManager->EMNodeManager->sender.ask(EngineLaunchRequest)->EngineManager service->EngineNodeManager->EngineLocker->Engine->EngineNodeManager->EngineFactory=>EngineService=> ServerInstance When creating an engine is the part that interacts with RM, EnginePlugin should return specific resource types through Labels, and then AM sends resource requests to RM.",-1),i("p",null,"        Engine reuse: In order to reduce the time and resources consumed for engine startup, the principle of reuse must be given priority to the use of engines. Reuse generally refers to the reuse of engines that users have created. The engine reuse module is responsible for providing a collection of reusable engines. Election and lock the engine and start using it, or return that there is no engine that can be reused. ReuseEngienRequest->RPC/Rest -> MasterEventHandler ->ReuseEngineService -> ->abelContext->EngineNodeManager->EngineSelector->EngineLocker->Engine->EngineNodeManager->EngineReuser->EngineService=>ServerInstance",-1),i("p",null,"        Engine switching: It mainly refers to the label switching of existing engines. For example, when the engine is created, it was created by Creator1. Now it can be changed to Creator2 by engine switching. At this time, you can allow the current engine to receive tasks with the tag Creator2. SwitchEngienRequest->RPC/Rest -> MasterEventHandler ->SwitchEngineService ->LabelContext/EnginePlugin/RMResourcevice->EngineNodeManager->EngineLocker->Engine->EngineNodeManager->EngineReuser->EngineService=>ServerInstance. Engine manager: Engine manager is responsible for managing the basic information and metadata information of all engines.",-1)],u={setup:(i,{expose:a})=>(a({frontmatter:{}}),(i,a)=>(e(),n("div",l,c)))},E={class:"markdown-body"},d=[i("h2",null,"背景",-1),i("p",null,"针对旧版本Linkis的Entrance模块负责太多的职责，对Engine的管理能力较弱，且不易于后续的扩展，新抽出了AppManager模块，完成 以下职责：",-1),i("ol",null,[i("li",null,"新增AM模块将Entrance之前做的管理Engine的功能移动到AM模块"),i("li",null,"AM需要支持操作Engine，包括：新增、复用、回收、预热、切换等功能"),i("li",null,"需要对接Manager模块对外提供Engine的管理功能：包括Engine状态维护、引擎列表维护、引擎信息等"),i("li",null,"AM需要管理EM服务，需要完成EM的注册并将资源注册转发给RM进行EM的资源注册"),i("li",null,"AM需要对接Label模块，包括EM/Engine的增删需要通知标签管理器进行标签更新"),i("li",null,"AM另外需要对接标签模块进行标签解析，并需要通过一系列标签获取一些列打好分的serverInstance列表（EM和Engine怎么区分，1、标签完全不一样）"),i("li",null,"需要对外提供基础接口：包括引擎和引擎管理器的增删改，提供metric查询等")],-1),i("h2",null,"架构图",-1),i("p",null,[i("img",{src:s,alt:""})],-1),i("p",null,"如上图所示：AM在LinkisMaster中属于AppManager模块，作为一个Service提供服务",-1),i("p",null,[a("新引擎申请流程图： "),i("img",{src:g,alt:""})],-1),i("p",null,"从上面的引擎生命周期流程图可知，Entrance已经不在做Engine的管理工作，engine的启动和管理都由AM控制。",-1),i("h2",null,"架构说明：",-1),i("p",null,"AppManager主要包含了引擎服务和EM服务： 引擎服务包含了所有和引擎EngineConn相关的操作，如引擎创建、引擎复用、引擎切换、引擎回收、引擎停止、引擎销毁等。 EM服务负责所有EngineConnManager的信息管理，可以在线上对ECM进行服务管理，包括标签修改，暂停ECM服务，获取ECM实例信息，获取ECM运行的引擎信息，kill掉ECM操作，还可以根据EM Node的信息查询所有的EngineNode,也支持按用户查找，保存了EM Node的负载信息、节点健康信息、资源使用信息等。 新的EngineConnManager和EngineConn都支持标签管理，引擎的类型也增加了离线、流式、交互式支持。",-1),i("p",null,"引擎创建：专门负责LinkisManager服务的新建引擎功能，引擎启动模块完全负责一个新引擎的创建，包括获取ECM标签集合、资源申请、获得引擎启动命令，通知ECM新建引擎，更新引擎列表等。 CreateEngienRequest->RPC/Rest -> MasterEventHandler ->CreateEngineService -> ->LabelContext/EnginePlugin/RMResourcevice->（RcycleEngineService）EngineNodeManager->EMNodeManager->sender.ask(EngineLaunchRequest)->EngineManager服务->EngineNodeManager->EngineLocker->Engine->EngineNodeManager->EngineFactory=>EngineService=>ServerInstance 在创建引擎是存在和RM交互的部分，EnginePlugin应该需要通过Lables返回具体的资源类型，然后AM向RM发送资源请求",-1),i("p",null,"引擎复用：为了减少引擎启动所耗费的时间和资源，引擎使用必须优先考虑复用原则，复用一般是指复用用户已经创建好的引擎，引擎复用模块负责提供可复用引擎集合，选举并锁定引擎后开始使用，或者返回没有可以复用的引擎。 ReuseEngienRequest->RPC/Rest -> MasterEventHandler ->ReuseEngineService -> ->abelContext->EngineNodeManager->EngineSelector->EngineLocker->Engine->EngineNodeManager->EngineReuser->EngineService=>ServerInstance",-1),i("p",null,"引擎切换：主要是指对已有引擎进行标签切换，例如创建引擎的时候是由Creator1创建的，现在可以通过引擎切换改成Creator2。这个时候就可以允许当前引擎接收标签为Creator2的任务了。 SwitchEngienRequest->RPC/Rest -> MasterEventHandler ->SwitchEngineService ->LabelContext/EnginePlugin/RMResourcevice->EngineNodeManager->EngineLocker->Engine->EngineNodeManager->EngineReuser->EngineService=>ServerInstance",-1),i("p",null,"引擎管理器：引擎管理负责管理所有引擎的基本信息、元数据信息",-1)],M={setup:(i,{expose:a})=>(a({frontmatter:{}}),(i,a)=>(e(),n("div",E,d)))},p={setup(n){const i=t(localStorage.getItem("locale")||"en");return(n,a)=>"en"===i.value?(e(),r(o(u),{key:0})):(e(),r(o(M),{key:1}))}};export{p as default};
