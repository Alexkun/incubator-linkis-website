import{o as e,c as l,b as a,e as t,r as n,l as i,u as s}from"./vendor.1180558b.js";var o="/assets/label_manager_global.91aa80e7.png",r="/assets/label_manager_scorer.fd531e4a.png";const c={class:"markdown-body"},u=[a("h2",null,"LabelManager architecture design",-1),a("h4",null,"Brief description",-1),a("p",null,"LabelManager is a functional module in Linkis that provides label services to upper-level applications. It uses label technology to manage cluster resource allocation, service node election, user permission matching, and gateway routing and forwarding; it includes generalized analysis and processing tools that support various custom Label labels, And a universal tag matching scorer.",-1),a("h3",null,"Overall architecture schematic",-1),a("p",null,[a("img",{src:o,alt:"整体架构示意图"})],-1),a("h4",null,"Architecture description",-1),a("ul",null,[a("li",null,"LabelBuilder: Responsible for the work of label analysis. It can parse the input label type, keyword or character value to obtain a specific label entity. There is a default generalization implementation class or custom extensions."),a("li",null,"LabelEntities: Refers to a collection of label entities, including cluster labels, configuration labels, engine labels, node labels, routing labels, search labels, etc."),a("li",null,"NodeLabelService: The associated service interface class of instance/node and label, which defines the interface method of adding, deleting, modifying and checking the relationship between the two and matching the instance/node according to the label."),a("li",null,"UserLabelService: Declare the associated operation between the user and the label."),a("li",null,"ResourceLabelService: Declare the associated operations of cluster resources and labels, involving resource management of combined labels, cleaning or setting the resource value associated with the label."),a("li",null,"NodeLabelScorer: Node label scorer, corresponding to the implementation of different label matching algorithms, using scores to indicate node label matching.")],-1),a("h3",null,"1. LabelBuilder parsing process",-1),a("p",null,"Take the generic label analysis class GenericLabelBuilder as an example to clarify the overall process: The process of label parsing/construction includes several steps:",-1),a("ol",null,[a("li",null,"According to the input, select the appropriate label class to be parsed."),a("li",null,"According to the definition information of the tag class, recursively analyze the generic structure to obtain the specific tag value type."),a("li",null,"Convert the input value object to the tag value type, using implicit conversion or positive and negative analysis framework."),a("li",null,"According to the return of 1-3, instantiate the label, and perform some post operations according to different label classes.")],-1),a("h3",null,"2. NodeLabelScorer scoring process",-1),a("p",null,[t("In order to select a suitable engine node based on the tag list attached to the Linkis user execution request, it is necessary to make a selection of the matching engine list, which is quantified as the tag matching degree of the engine node, that is, the score. In the label definition, each label has a feature value, namely CORE, SUITABLE, PRIORITIZED, OPTIONAL, and each feature value has a boost value, which is equivalent to a weight and an incentive value. At the same time, some features such as CORE and SUITABLE must be unique features, that is, strong filtering is required during the matching process, and a node can only be associated with one CORE/SUITABLE label. According to the relationship between existing tags, nodes, and request attached tags, the following schematic diagram can be drawn: "),a("img",{src:r,alt:"标签打分"})],-1),a("p",null,"The built-in default scoring logic process should generally include the following steps:",-1),a("ol",null,[a("li",null,[t("The input of the method should be two sets of network relationship lists, namely "),a("code",null,"Label -> Node"),t(" and "),a("code",null,"Node -> Label"),t(", where the Node node in the "),a("code",null,"Node -> Label"),t(" relationship must have all the CORE and SUITABLE feature labels, these nodes are also called candidate nodes.")]),a("li",null,[t("The first step is to traverse and calculate the relationship list of "),a("code",null,"Node -> Label"),t(", and traverse the label Label associated with each node. In this step, the label is scored first. If the label is not the label attached to the request, the score is 0. Otherwise, the score is divided into: (basic score/the number of times the tag corresponds to the feature value in the request) * the incentive value of the corresponding feature value, where the basic score defaults to 1, and the initial score of the node is the sum of the associated tag scores; where because The CORE/SUITABLE type label must be the only label, and the number of occurrences is always 1.")]),a("li",null,[t("After obtaining the initial score of the node, the second step is to traverse the calculation of the "),a("code",null,"Label -> Node"),t(" relationship. Since the first step ignores the effect of unrequested attached labels on the score, the proportion of irrelevant labels will indeed affect the score. This type of label is unified with the UNKNOWN feature, and this feature also has a corresponding incentive value; We set that the higher the proportion of candidate nodes associated with irrelevant labels in the total associated nodes, the more significant the impact on the score, which can further accumulate the initial score of the node obtained in the first step.")]),a("li",null,"Normalize the standard deviation of the scores of the candidate nodes and sort them.")],-1)],h={setup:(a,{expose:t})=>(t({frontmatter:{}}),(a,t)=>(e(),l("div",c,u)))};const d={class:"markdown-body"},b=[a("h2",null,"LabelManager 架构设计",-1),a("h4",null,"简述",-1),a("p",null,"LabelManager是Linkis中对上层应用提供标签服务的功能模组，运用标签技术管理集群资源分配、服务节点选举、用户权限匹配以及网关路由转发；包含支持各种自定义Label标签的泛化解析处理工具，以及通用的标签匹配评分器。",-1),a("h3",null,"整体架构示意",-1),a("p",null,[a("img",{src:o,alt:"整体架构示意图"})],-1),a("h4",null,"架构说明",-1),a("ul",null,[a("li",null,"LabelBuilder: 承担着标签解析的工作，从输入的标签类型、关键字或者字符数值中解析得到具体的标签实体，有默认的泛化实现类也可做自定义扩展。"),a("li",null,"LabelEntities: 指代标签实体集合，有且包含集群标签，配置标签，引擎标签，节点标签，路由标签，搜索标签等。"),a("li",null,"NodeLabelService: 实例/节点与标签的关联服务接口类，定义对两者关联关系的增删改查以及根据标签匹配实例/节点的接口方法。"),a("li",null,"UserLabelService: 声明用户与标签的关联操作。"),a("li",null,"ResourceLabelService: 声明集群资源与标签的关联操作，涉及到对组合标签的资源管理，清理或设置标签关联的资源数值。"),a("li",null,"NodeLabelScorer: 节点标签评分器，对应不同的标签匹配算法的实现，使用评分表示节点的标签匹配度。")],-1),a("h3",null,"一. LabelBuilder解析流程",-1),a("p",null,[t("以泛化标签解析类GenericLabelBuilder为例，阐明整体流程:"),a("br"),a("img",{src:"/assets/label_manager_builder.caf90f90.png",alt:"泛化标签解析流程"}),a("br"),t(" 标签解析/构建的流程概括包含几步:")],-1),a("ol",null,[a("li",null,"根据输入选择要构建解析的合适标签类。"),a("li",null,"根据标签类的定义信息，递归解析泛型结构，得到具体的标签值类型。"),a("li",null,"转化输入值对象到标签值类型，运用隐式转化或正反解析框架。"),a("li",null,"根据1-3的返回，实例化标签，并根据不同的标签类进行一些后置操作。")],-1),a("h3",null,"二. NodeLabelScorer打分流程",-1),a("p",null,[t("为了根据Linkis用户执行请求中附带的标签列表挑选合适的引擎节点，需要对符合的引擎列表做择优，量化为引擎节点的标签匹配度即评分。"),a("br"),t(" 在标签定义里，每个标签都有feature特征值，分别为CORE，SUITABLE，PRIORITIZED，OPTIONAL，每个特征值都有一个boost值，相当于权重和激励值， 同时有些特征例CORE和SUITABLE为必须唯一特征即在匹配过程中需做强过滤，且一个节点只能分别关联一个CORE/SUITABLE标签。"),a("br"),t(" 根据现有标签，节点，请求附带标签三者之间的关系，可以绘制出如下示意图："),a("br"),a("img",{src:r,alt:"标签打分"})],-1),a("p",null,"自带的默认评分逻辑过程应大体包含以下几点步骤:",-1),a("ol",null,[a("li",null,[t("方法的输入应该为两组网络关系列表，分别是"),a("code",null,"Label -> Node"),t(" 和 "),a("code",null,"Node -> Label"),t("， 其中"),a("code",null,"Node -> Label"),t("关系里的Node节点必须具有请求里涉及到所有CORE以及SUITABLE特征的标签，这些节点也称为备选节点。")]),a("li",null,[t("第一步遍历计算"),a("code",null,"Node -> Label"),t("关系列表，遍历每个节点关联的标签Label，这一步先给标签打分，如果标签不是请求中附带的标签，打分为0， 否则打分为： (基本分/该标签对应特征值在请求中的出现次数) * 对应特征值的激励值，其中基本分默认为1，节点的初始分为相关联的标签打分的总和；其中因为CORE/SUITABLE类型标签为必须唯一标签，出现次数恒定为1。")]),a("li",null,[t("得到节点的初始分后，第二步遍历计算"),a("code",null,"Label -> Node"),t("关系，由于第一步中忽略了非请求附带标签对评分的作用，但无关标签比重确实会对评分造成影响，对应这类的标签统一打上UNKNOWN的特征，同样该特征也有相对应的激励值； 我们设定无关标签关联的备选节点占总关联节点的比重越高，对评分的影响越显著，以此可以对第一步得出的节点初始分做进一步累加。")]),a("li",null,"对得到的备选节点的分数做标准差归一化，并排序。")],-1)],g={setup:(a,{expose:t})=>(t({frontmatter:{}}),(a,t)=>(e(),l("div",d,b)))},f={setup(l){const a=n(localStorage.getItem("locale")||"en");return(l,t)=>"en"===a.value?(e(),i(s(h),{key:0})):(e(),i(s(g),{key:1}))}};export{f as default};
