import{o as n,c as e,b as i,e as a,r as t,l as s,u as l}from"./vendor.1180558b.js";var r="/assets/Linkis0.X_services_list.984b5164.png",o="/assets/Linkis1.0_services_list.72702c4a.png",c="/assets/Linkis0.X_newengine_architecture.76e9d9b8.png",g="/assets/Linkis1.0_newengine_architecture.e98645d5.png",u="/assets/Linkis1.0_newengine_initialization.6acbb6c3.png",p="/assets/Linkis1.0_engineconn_architecture.7d420481.png";const d={class:"markdown-body"},m=[i("h2",null,"1. Brief Description",-1),i("p",null,[a("        First of all, the Entrance and EngineConnManager (formerly EngineManager) services under the Linkis1.0 architecture are completely unrelated to the engine. That is, under the Linkis1.0 architecture, each engine does not need to be implemented and started the corresponding Entrance and EngineConnManager, and Linkis1.0’s Each Entrance and EngineConnManager can be shared by all engines."),i("br"),a("         Secondly, Linkis1.0 added the Linkis-Manager service to provide external AppManager (application management), ResourceManager (resource management, the original ResourceManager service) and LabelManager (label management) capabilities."),i("br"),a("         Then, in order to reduce the difficulty of implementing and deploying a new engine, Linkis 1.0 re-architects a module called EngineConnPlugin. Each new engine only needs to implement the EngineConnPlugin interface.Linkis EngineConnPluginServer supports dynamic loading of EngineConnPlugin (new engine) in the form of a plug-in. Once EngineConnPluginServer is successfully loaded, EngineConnManager can quickly start an instance of the engine for the user."),i("br"),a("         Finally, all the microservices of Linkis are summarized and classified, which are generally divided into three major levels: public enhancement services, computing governance services and microservice governance services, from the code hierarchy, microservice naming and installation directory structure, etc. To standardize the microservice system of Linkis1.0.")],-1),i("h2",null,"2. Main Feature",-1),i("ol",null,[i("li",null,[i("strong",null,"Strengthen computing governance"),a(", Linkis 1.0 mainly strengthens the comprehensive management and control capabilities of computing governance from engine management, label management, ECM management, and resource management. It is based on the powerful management and control design concept of labeling. This makes Linkis 1.0 a solid step towards multi-IDC, multi-cluster, and multi-container.")]),i("li",null,[i("strong",null,"Simplify user implementation of new engines"),a(", EnginePlugin is used to integrate the related interfaces and classes that need to be implemented to implement a new engine, as well as the Entrance-EngineManager-Engine three-tier module system that needs to be split into one interface. , Simplify the process and code for users to implement the new engine, so that as long as one class is implemented, a new engine can be connected.")]),i("li",null,[i("strong",null,"Full-stack computing storage engine support"),a(", to achieve full coverage support for computing request scenarios (such as Spark), storage request scenarios (such as HBase), and resident cluster services (such as SparkStreaming).")]),i("li",null,[i("strong",null,"Improved advanced computing strategy capability"),a(", add Orchestrator to implement rich computing task management strategies, and support tag-based analysis and orchestration.")])],-1),i("h2",null,"3. Service Comparison",-1),i("p",null,[a("        Please refer to the following two pictures:"),i("br"),i("img",{src:r,alt:"Linkis0.X Service List"}),i("br"),a("         The list of Linkis1.0 microservices is as follows:"),i("br"),i("img",{src:o,alt:"Linkis1.0 Service List"}),i("br"),a("         From the above two figures, Linkis1.0 divides services into three types of services: Computing Governance (CG)/Micro Service Governance (MG)/Public Enhanced Service (PS). among them:")],-1),i("ol",null,[i("li",null,"A major change in computing governance is that Entrance and EngineConnManager services are no longer related to engines. To implement a new engine, only the EngineConnPlugin plug-in needs to be implemented. EngineConnPluginServer will dynamically load the EngineConnPlugin plug-in to achieve engine hot-plug update;"),i("li",null,"Another major change in computing governance is that LinkisManager, as the management brain of Linkis, abstracts and defines AppManager (application management), ResourceManager (resource management) and LabelManager (label management);"),i("li",null,"Microservice management service, merged and unified the Eureka and Gateway services in the 0.X part, and enhanced the functions of the Gateway service to support routing and forwarding according to Label;"),i("li",null,"Public enhancement services, mainly to optimize and unify the BML services/context services/data source services/public services of the 0.X part, which is convenient for everyone to manage and view.")],-1),i("h2",null,"4. Introduction To Linkis Manager",-1),i("p",null,[a("        As the management brain of Linkis, Linkis Manager is mainly composed of AppManager, ResourceManager and LabelManager."),i("br"),a("         ResourceManager not only has Linkis0.X’s resource management capabilities for Yarn and Linkis EngineManager, but also provides tag-based multi-level resource allocation and recycling capabilities, allowing ResourceManager to have full resource management capabilities across clusters and across computing resource types."),i("br"),a("         AppManager will coordinate and manage all EngineConnManager and EngineConn, and the life cycle of EngineConn application, reuse, creation, switching, and destruction will be handed over to AppManager for management."),i("br"),a("         The LabelManager will provide cross-IDC and cross-cluster EngineConn and EngineConnManager routing and management capabilities based on multi-level combined tags.")],-1),i("h2",null,"5. Introduction To Linkis EngineConnPlugin",-1),i("p",null,'        EngineConnPlugin is mainly used to reduce the cost of access and deployment of new computing storage. It truly enables users to “just need to implement a class to connect to a new computing storage engine; just execute a script to quickly deploy a new engine ".',-1),i("h3",null,"5.1 New Engine Implementation Comparison",-1),i("p",null,[a("        The following are the relevant interfaces and classes that the user Linkis0.X needs to implement to implement a new engine:"),i("br"),i("img",{src:c,alt:"Linkis0.X How to implement a brand new engine"}),i("br"),a("         The following is Linkis 1.0.0, which implements a new engine, the interfaces and classes that users need to implement:"),i("br"),i("img",{src:g,alt:"Linkis1.0 How to implement a brand new engine"}),i("br"),a("         Among them, EngineConnResourceFactory and EngineLaunchBuilder are not required to implement interfaces, and only EngineConnFactory is required to implement interfaces.")],-1),i("h3",null,"5.2 New engine startup process",-1),i("p",null,[a("        EngineConnPlugin provides the Server service to start and load all engine plug-ins. The following is a new engine startup that accesses the entire process of EngineConnPlugin-Server:"),i("br"),i("img",{src:u,alt:"Linkis Engine start process"})],-1),i("h2",null,"6. Introduction To Linkis EngineConn",-1),i("p",null,[a("        EngineConn, the original Engine module, is the actual unit for Linkis to connect and interact with the underlying computing storage engine, and is the basis for Linkis to provide computing and storage capabilities."),i("br"),a("         EngineConn of Linkis1.0 is mainly composed of EngineConn and Executor. among them:")],-1),i("ol",null,[i("li",null,[i("p",null,"EngineConn is the connector, which contains the session information between the engine and the specific cluster. It only acts as a connection, a client, and does not actually perform calculations.")]),i("li",null,[i("p",null,"Executor is the executor. As a real computing scene executor, it is the actual computing logic execution unit, and it also abstracts various specific capabilities of the engine, such as providing various services such as locking, access status, and log acquisition.")]),i("li",null,[i("p",null,"Executor is created by the session information in EngineConn. An engine type can support multiple different types of computing tasks, each corresponding to the implementation of an Executor, and the computing task will be submitted to the corresponding Executor for execution. In this way, the same engine can provide different services according to different computing scenarios. For example, the permanent engine does not need to be locked after it is started, and the one-time engine does not need to support Receiver and access status after it is started.")]),i("li",null,[i("p",null,[a("The advantage of using the separation of Executor and EngineConn is that it can avoid the Receiver coupling business logic, and only retains the RPC communication function. Distribute services in multiple Executor modules, and abstract them into several categories of engines: interactive computing engines, streaming engines, disposable engines, etc., which may be used, and build a unified engine framework for later expansion. In this way, different types of engines can respectively load the required capabilities according to their needs, which greatly reduces the redundancy of engine implementation."),i("br"),a("         As shown below:"),i("br"),i("img",{src:p,alt:"Linkis EngineConn Architecture diagram"})])])],-1)],h={setup:(i,{expose:a})=>(a({frontmatter:{}}),(i,a)=>(n(),e("div",d,m)))},E={class:"markdown-body"},f=[i("h2",null,"1. 简述",-1),i("p",null,[a("     首先，Linkis1.0 架构下的 Entrance 和 EngineConnManager（原EngineManager）服务与 "),i("strong",null,"引擎"),a(" 已完全无关，即： 在 Linkis1.0 架构下，每个引擎无需再配套实现并启动对应的 Entrance 和 EngineConnManager，Linkis1.0 的每个 Entrance 和 EngineConnManager 都可以给所有引擎共用。")],-1),i("p",null,"     其次，Linkis1.0 新增了Linkis-Manager服务用于对外提供 AppManager（应用管理）、ResourceManager（资源管理，原ResourceManager服务）和 LabelManager（标签管理）的能力。",-1),i("p",null,"     然后，为了降低大家实现和部署一个新引擎的难度，Linkis 1.0 重新架构了一个叫 EngineConnPlugin 的模块，每个新引擎只需要实现 EngineConnPlugin 接口即可， Linkis EngineConnPluginServer 支持以插件的形式动态加载 EngineConnPlugin（新引擎），一旦 EngineConnPluginServer 加载成功，EngineConnManager 便可为用户快速启动一个该引擎实例。",-1),i("p",null,"     最后，对Linkis的所有微服务进行了归纳分类，总体分为了三个大层次：公共增强服务、计算治理服务和微服务治理服务，从代码层级结构、微服务命名和安装目录结构等多个方面来规范Linkis1.0的微服务体系。",-1),i("h2",null,"2. 主要特点",-1),i("ol",null,[i("li",null,[i("p",null,[i("strong",null,"强化计算治理"),a("，Linkis1.0主要从引擎管理、标签管理、ECM管理和资源管理等几个方面，全面强化了计算治理的综合管控能力，基于标签化的强大管控设计理念，使得Linkis1.0向多IDC化、多集群化、多容器化，迈出了坚实的一大步。")])]),i("li",null,[i("p",null,[i("strong",null,"简化用户实现新引擎"),a("，EnginePlugin用于将原本实现一个新引擎，需要实现的相关接口和类，以及需要拆分的Entrance-EngineManager-Engine三层模块体系，融合到了一个接口之中，简化用户实现新引擎的流程和代码，真正做到只要实现一个类，就能接入一个新引擎。")])]),i("li",null,[i("p",null,[i("strong",null,"全栈计算存储引擎支持"),a("，实现对计算请求场景（如Spark）、存储请求场景（如HBase）和常驻集群型服务（如SparkStreaming）的全面覆盖支持。")])]),i("li",null,[i("p",null,[i("strong",null,"高级计算策略能力改进"),a("，新增Orchestrator实现丰富计算任务管理策略，且支持基于标签的解析和编排。")])]),i("li",null,[i("p",null,[i("strong",null,"安装部署改进"),a(" 优化一键安装脚本，支持容器化部署，简化用户配置。")])])],-1),i("h2",null,"3. 服务对比",-1),i("p",null,"     请参考以下两张图：",-1),i("p",null,"     Linkis0.X 微服务列表如下：",-1),i("p",null,[i("img",{src:r,alt:"Linkis0.X服务列表"})],-1),i("p",null,"     Linkis1.0 微服务列表如下：",-1),i("p",null,[i("img",{src:o,alt:"Linkis1.0服务列表"})],-1),i("p",null,"     从上面两个图中看，Linkis1.0 将服务分为了三类服务：计算治理（英文缩写CG）/微服务治理（MG）/公共增强服务(PS)。其中：",-1),i("ol",null,[i("li",null,[i("p",null,"计算治理的一大变化是，Entrance 和 EngineConnManager服务与引擎再不相关，实现一个新引擎只需实现 EngineConnPlugin插件即可，EngineConnPluginServer会动态加载 EngineConnPlugin 插件，做到引擎热插拔式更新；")]),i("li",null,[i("p",null,"计算治理的另一大变化是，LinkisManager作为 Linkis 的管理大脑，抽象和定义了 AppManager（应用管理）、ResourceManager（资源管理）和LabelManager（标签管理）；")]),i("li",null,[i("p",null,"微服务治理服务，将0.X部分的Eureka和Gateway服务进行了归并统一，并对Gateway服务进行了功能增强，支持按照Label进行路由转发；")]),i("li",null,[i("p",null,"公共增强服务，主要将0.X部分的BML服务/上下文服务/数据源服务/公共服务进行了优化和归并统一，便于大家管理和查看。")])],-1),i("h2",null,"4. Linkis Manager简介",-1),i("p",null,"     Linkis Manager 作为 Linkis 的管理大脑，主要由 AppManager、ResourceManager 和 LabelManager 组成。",-1),i("p",null,"     ResourceManager 不仅具备 Linkis0.X 对 Yarn 和 Linkis EngineManager 的资源管理能力，还将提供基于标签的多级资源分配和回收能力，让 ResourceManager 具备跨集群、跨计算资源类型的全资源管理能力；",-1),i("p",null,"     AppManager 将统筹管理所有的 EngineConnManager 和 EngineConn，EngineConn 的申请、复用、创建、切换、销毁等生命周期全交予 AppManager进行管理；",-1),i("p",null,"     而 LabelManager 将基于多级组合标签，提供跨IDC、跨集群的 EngineConn 和 EngineConnManager 路由和管控能力；",-1),i("h2",null,"5. Linkis EngineConnPlugin简介",-1),i("p",null,"     EngineConnPlugin 主要用于降低新计算存储的接入和部署成本，真正做到让用户“只需实现一个类，就能接入一个全新计算存储引擎；只需执行一下脚本，即可快速部署一个全新引擎”。",-1),i("h3",null,"5.1 新引擎实现对比",-1),i("p",null,"     以下是用户Linkis0.X实现一个新引擎需要实现的相关接口和类：",-1),i("p",null,[i("img",{src:c,alt:"Linkis0.X 如何实现一个全新引擎"})],-1),i("p",null,"     以下为Linkis1.0.0，实现一个新引擎，用户需实现的接口和类：",-1),i("p",null,[i("img",{src:g,alt:"Linkis1.0 如何实现一个全新引擎"})],-1),i("p",null,"     其中EngineConnResourceFactory和EngineLaunchBuilder为非必需实现接口，只有EngineConnFactory为必需实现接口。",-1),i("h3",null,"5.2 新引擎启动流程",-1),i("p",null,"     EngineConnPlugin 提供了 Server 服务，用于启动和加载所有的引擎插件，以下给出了一个新引擎启动，访问了 EngineConnPlugin-Server 的全部流程：",-1),i("p",null,[i("img",{src:u,alt:"Linkis 引擎启动流程"})],-1),i("h2",null,"6. Linkis EngineConn简介",-1),i("p",null,"     EngineConn，即原 Engine 模块，作为 Linkis 与底层计算存储引擎进行连接和交互的实际单元，是 Linkis 提供计算存储能力的基础。",-1),i("p",null,"     Linkis1.0 的 EngineConn 主要由 EngineConn 和 Executor构成。其中：",-1),i("p",null,"a) EngineConn 为连接器，包含引擎与具体集群的会话信息。它只是起到一个连接，一个客户端的作用，并不真正的去执行计算。",-1),i("p",null,"b) Executor 为执行器，作为真正的计算场景执行器，是实际的计算逻辑执行单元，也对引擎各种具体能力的抽象，例如提供加锁、访问状态、获取日志等多种不同的服务。",-1),i("p",null,"c) Executor 通过 EngineConn 中的会话信息进行创建，一个引擎类型可以支持多种不同种类的计算任务，每种对应一个 Executor 的实现，计算任务将被提交到对应的 Executor 进行执行。 这样，同一个引擎能够根据不同的计算场景提供不同的服务。比如常驻式引擎启动后不需要加锁，一次性引擎启动后不需要支持 Receiver 和访问状态等。",-1),i("p",null,"d) 采用 Executor 和 EngineConn 分离的方式的好处是，可以避免 Receiver 耦合业务逻辑，本身只保留 RPC 通信功能。将服务分散在多个 Executor 模块中，并且抽象成几大类引擎：交互式计算引擎、流式引擎、一次性引擎等等可能用到的，构建成统一的引擎框架，便于后期的扩充。 这样不同类型引擎可以根据需要分别加载其中需要的能力，大大减少引擎实现的冗余。",-1),i("p",null,"     如下图所示：",-1),i("p",null,[i("img",{src:p,alt:"Linkis EngineConn架构图"})],-1)],v={setup:(i,{expose:a})=>(a({frontmatter:{}}),(i,a)=>(n(),e("div",E,f)))},k={setup(e){const i=t(localStorage.getItem("locale")||"en");return(e,a)=>"en"===i.value?(n(),s(l(h),{key:0})):(n(),s(l(v),{key:1}))}};export{k as default};
